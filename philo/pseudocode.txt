essayons d'integrer un serveur.

- Un thread demarre pour chaque philosophers avec la structure du philo en parametre.

- Le thread principal pourra checker le status de chaque philo en boucle. Si mort il y a, il print philo dead puis free / quitte tout.

- Chaque philo executera une routine qui se declinera en trois parties :
	a. TIME TO EAT
	b. TIME TO SLEEP
	c. TIME TO THINK

- Au moment de manger, chaque philo demandera a manger au serveur.
	Le serveur verifiera que les fourchettes correspondant a la demande sont disponibles.
	Si l'acces est donne au philo, le serveur notera que ces fourchettes sont prises au moyen de booleens.
	Lorsque le philo a fini de manger, les fourchettes sont liberees et le booleen est reset par le serveur.
	Pour que les philo alternent et mangent au bon moment, une file d'attente est tenue par le serveur.

- Une file d'attente assurera qu'aucun philo n'ait rien a manger rien pendant plusieurs tours.
	Le serveur tient une file d'attente, en pushant sur le devant de la liste les philo ayant mange le plus tot.
	Si un voisin d'un philo qui a plus faim demande a se servir, le serveur refusera pour laisser la priorite au plus affame.




SYSTEM DE QUEUE

- Un philo demande a manger
	1. fourchettes dispo	-> mange
	2. fourchettes indispo	-> variable booleenne "attendre" = 1 | queue philo
while (attendre == 1)
	usleep(100);
- Quand la fourchette manquante est dispo
	serveur set "attendre" = 0


NOMBRE IMPAIR
2. Tout le monde check si wait = 0 -> Tout le monde demande a manger.
3. Serveur dit oui aux premiers -> mutex_lock sur fourchettes des autorises | Booleens fork_taken = 1.
4. Serveur dit non aux autres -> wait = 1.
5. autorises fini de manger -> fork_taken = 0 | serveur check fork availability -> if fork_taken = 0 , wait = 0
6. tout le monde check si wait = 0 -> Tout le monde demande a manger